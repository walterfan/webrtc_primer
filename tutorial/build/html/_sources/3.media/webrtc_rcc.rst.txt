################################
WebRTC RTP Congestion Control
################################


.. include:: ../links.ref
.. include:: ../tags.ref
.. include:: ../abbrs.ref

============ ==========================
**Abstract** WebRTC RTP 拥塞控制
**Authors**  Walter Fan
**Status**   WIP
**Updated**  |date|
============ ==========================

.. |date| date::

.. contents::
   :local:


简介
=========================
视频会议需要低延迟和高带宽

* 基于延迟的控制器 delay-based controller
* 基于丢包的控制器 loss-based controller


基本架构
=========================

在发送方，根据 RTCP Receiver Report 中的 faction lost 得知丢包率，可以调整发送的码率

在接收方，根据 RTP 包到达的时间延迟，通过 arrival time filter, 估算出网络延迟 m(ti), 经过 over-user detector 来判断当前网络的拥塞情况， 再由 Remote rate controller 根据规则计算出最大码率 Ar, 通过 RTCP REMB 消息将 Ar 发回给发送方。 发送方再由 A_s, A_r 和配置，计算出目标的码率 A, 应用到 Encoder 和 Packed Sender 来控制发送方的码率。


.. image:: ../_static/gcc-architecture.png
   :alt: gcc-architecture

术语
=========================
* RMCAT: RTP Media Congestion Avoidance Techniques 即 RTP 媒体拥塞避免技术
  
* 排队延迟

* 延迟梯度

* 卡尔曼滤波

* inter-depature delta time

* inter-arrival delta time

* inter-group delay variation

* BBR

* PCC


交互式实时媒体的拥塞控制的需求
============================================

基本要求：在最多几百毫秒之内，接收方能够连贯流畅地听到或看到发送方的声音，图像或视频。

具体要求, 参见 `RFC8836`

1.   The congestion control algorithm MUST attempt to provide as-low-as-possible-delay transit for interactive real-time traffic while still providing a useful amount of bandwidth.

2.   The algorithm MUST be fair to other flows, both real-time flows (such as other instances of itself) and TCP flows, both long-lived flows and bursts such as the traffic generated by a typical web-browsing session. 

3.   The algorithm SHOULD NOT starve competing TCP flows and SHOULD, as best as possible, avoid starvation by TCP flows

4.   The algorithm SHOULD adapt as quickly as possible to initial network conditions at the start of a flow. 


5.   The algorithm SHOULD be stable if the RTP streams are halted or discontinuous (for example, when using Voice Activity Detection).

6.   Where possible, the algorithm SHOULD merge information across multiple RTP streams sent between two endpoints when those RTP streams share a common bottleneck, whether or not those streams are multiplexed onto the same ports.
   
7.   The algorithm SHOULD NOT require any special support from network elements to be able to convey congestion-related information. 

8.   Since the assumption here is a set of RTP streams, the backchannel typically SHOULD be done via the RTP Control Protocol (RTCP)

9.   Flows managed by this algorithm and flows competing against each other at a bottleneck may have different Differentiated Services Code Point (DSCP) [RFC5865] markings depending on the type of traffic or may be subject to flow-based QoS.
    
10.  The algorithm SHOULD sense the unexpected lack of backchannel information as a possible indication of a channel-overuse problem and react accordingly to avoid burst events causing a congestion collapse.

11.  The algorithm SHOULD be stable and maintain low delay when faced  with Active Queue Management (AQM) algorithms.  Also note that these algorithms may apply across multiple queues in the bottleneck or to a single queue.

平滑发送 Smooth/Paced Sender
============================================
* send rate
* ack rate
  
Google Congestion Control
============================================

1. 到达时间滤波器 arrival time filter

两个包发送的间隔 T(i) – T(i-1) 和接收的间隔 t(i) – t(i-1) 在理想情况下是相同的，实际上会有不同.
也就是说包的到达时间并未保持稳定的速度。 在计算的时候可以用以帧分组，对两个组的到达时间进行计算。

.. image:: ../_static/rtp_packet_skew.png
   :alt: packet transmission delay


.. code-block::

   # 发送间隔与到达时间之间的延时
   d(i) = t(i) – t(i-1) – (T(i) – T(i-1))

   # 两组包之间的大小之差
   dL(i) = L(i) - l(i-1)

   # C(i) 表示带宽
   d(i) = dL(i)/C(i) + m(i) + v(i)   

   其中dL(i)表示相邻两帧的长度差，
   C(i)表示网络信道容量，
   m(i)表示网络排队延迟，
   v(i)表示网络抖动或其他延迟噪声。

   C(i) 是我们想预测的带宽，m(i)即是我们要求得的网络排队延迟, 可由 Kalman Filter 求得

T(i)是第i个数据包组中第一个数据包的发送时间，t(i)是第i个数据包组中最后一个数据包的到达时间


2. 过载检查器 over-use detector

3. 速率控制器 rate controller


测试与验证
======================


参考代码
======================
* https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/
  - congestion_controller/
  - remote_bitrate_estimator/


参考资料
=========================
* `REMB`_ : RTCP message for Receiver Estimated Maximum Bitrate

* `A Google Congestion Control Algorithm for Real-Time Communication`_

* `Analysis and Design of the Google Congestion Control for WebRTC <https://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf>`_

* `GCC Introduction`_

* `RFC8825`_: Overview: Real-Time Protocols for Browser-Based Applications
* `RFC8836`_: Congestion Control Requirements for Interactive Real-Time Media
* `RFC8083`_: Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions

* `RMCAT documents`_: RTP Media Congestion Avoidance Techniques documents

.. _RMCAT documents: https://datatracker.ietf.org/wg/rmcat/documents/

.. _A Google Congestion Control Algorithm for Real-Time Communication: https://datatracker.ietf.org/doc/html/draft-alvestrand-rmcat-congestion-03
.. _GCC Introduction: https://www.cnblogs.com/wangyiyunxin/p/11122003.html

.. _RFC8083: https://www.rfcreader.com/#rfc8083


Congestion Control for WebRTC: Standardization Status and Open Issues
-------------------------------------------------------------------------

.. sidebar:: Congestion Control for WebRTC: Standardization Status and Open Issues
   :subtitle: Author: Luca De Cicco, Gaetano Carlucci, and Saverio Mascolo


   The suggested approach is to multiplex all the RTP packet streams in a single RTP session sent over one transport layer flow to reduce the number of flows to be handled by NATs. 
   
   Following this approach, the Media Congestion Control algorithm computes the total sending rate A for the aggregated RTP session based on a set of metrics measured at the receiver and sent back
   through RTCP packets. 
   
   A rate allocation module allocates a fraction Ai of the total bitrate A to each media stream. In particular, each media stream is compressed at a target encoding rate  Ai  such that the sum of all these rates equals the computed sending rate A. 
   
   The media streams are then multiplexed over a single RTP session that feeds a sending engine. This module is responsible for sending the RTP packets to the network at a rate as close as possible to the rate computed by the congestion control algorithm. 
   
   It is worth noting that the placement of the congestion control algorithm is not specified and
   could be sender-side, receiver-side, or distributed both at sender and receiver. 
   
   As an example, Fig. 1 shows the case where the congestion control algorithm is placed only at the sender. The receiver is required to implement a module that  measures metrics to be fed back to the congestion control algorithm through RTCP packets.

   The section “Open Issues” will discuss the implications that such an architectural choice has on
   system scalability and deployability. 

.. image:: ../_static/webrtc-media-architecture.png
   :alt: WebRTC media application architecture

.. csv-table:: WEBRTC media flow requirements
   :header: "", "Requirement"
   :widths: 30, 30

   Latency, Possibly lower than 100ms
   Packet losses, "Should be minimized, FEC mechanism may be employed"
   Throughput, Should be as high as possible
   Burstiness, A smooth sending-rate should be produced
   Fairness, Should fairly share the bandwidth with real-time and data flows
   Starvation, Media flows should not be starved when competing with TCP flows
   Network support, No special network support should be required to operate


Goal
~~~~~~~~~~
the goal of the congestion control algorithm is to produce a sending rate as close as possible to the available end-to-end bandwidth while maintaining the queue occupancy as low as possible.

Additionally, media flows generated by WebRTC applications should fairly share network bandwidth with other concurrent flows. 


Design
~~~~~~~~~~

The design of an algorithm meeting these requirements is faced with several choices
with respect to

1. The transport protocol
2. Congestion detection
3. The actuation mechanism to be employed


The approaches to detect congestion through end-to-end measurements can be divided into
two main categories:

1. Loss-based algorithms, detecting congestion based on packet loss events
2. Delay-based algorithms, detecting congestion based on latency measurements.


Congestion detection can be either implicit,when based on end-to-end measurements performed at the end-points, or explicit, when congestion is measured directly in network elements by monitoring the router buffers lengths.


Delay-based algorithms are preferred to loss-based algorithms due to two reasons: 

* first, delay-based schemes can detect congestion before packets are lost due to buffer overflows; 
* second, loss based algorithms cannot control queuing delays since they continuously probe for the network available bandwidth by filling and draining Internet buffers, generating significant delay variations. 

Notice that explicitly controlling queuing delays is necessary, since excessively large buffers may
lead to latencies of the order of seconds [2]. 
An important issue to be taken into account is to prevent delay-based flows from being starved when
competing with loss-based flows in the best-effort Internet [7]. 
Congestion control algorithms may complement end-to-end measurements with explicit congestion signals sent from network elements to end-points through, for instance, the use of the explicit congestion notification (ECN) mechanism.


Concerning the actuation mechanism, the congestion control algorithm can either compute a congestion window (window-based approach) or explicitly compute a sending rate(rate-based approach). 

**The use of rate-based mechanisms makes it possible to directly use the rate computed by the congestion control algorithm to drive the media encoders, whereas in the case of window-based algorithms, a proper conversion from a window to a rate should be performed.**



.. image:: ../_static/rtp_packet_skew.png
   :alt: Two consecutive RTP packets are sent at time Ti–1 and Ti and received at time ti–1 and ti