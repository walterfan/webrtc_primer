

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>WebRTC RTP Congestion Control &mdash; webrtc_tutorial 1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Insertable Stream" href="insertable_stream.html" />
    <link rel="prev" title="WebRTC RTX" href="webrtc_rtx.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> webrtc_tutorial
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../outline.html">目录</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1.basic/index.html">1. WebRTC 基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2.transport/index.html">2. WebRTC 传输</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">3. WebRTC 媒体</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">WebRTC 媒体概论</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_audio.html">WebRTC 音频</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_video.html">WebRTC 视频</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_qos.html">WebRTC QoS</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_fec.html">WebRTC FEC</a></li>
<li class="toctree-l2"><a class="reference internal" href="webrtc_rtx.html">WebRTC RTX</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">WebRTC RTP Congestion Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">基本架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">术语</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">交互式实时媒体的拥塞控制的需求</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smooth-paced-sender">平滑发送 Smooth/Paced Sender</a></li>
<li class="toctree-l3"><a class="reference internal" href="#google-congestion-control">Google Congestion Control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">测试与验证</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">参考代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">参考资料</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#congestion-control-for-webrtc-standardization-status-and-open-issues">Congestion Control for WebRTC: Standardization Status and Open Issues</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="insertable_stream.html">Insertable Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="web_codec.html">Web Codecs</a></li>
<li class="toctree-l2"><a class="reference internal" href="web_transport.html">Web Transport</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4.practice/index.html">4. WebRTC 实践</a></li>
<li class="toctree-l1"><a class="reference internal" href="../5.tool/index.html">5. WebRTC 工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6.misc/index.html">6. WebRTC 关联技术</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">webrtc_tutorial</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">3. WebRTC 媒体</a> &raquo;</li>
        
      <li>WebRTC RTP Congestion Control</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/3.media/webrtc_rcc.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="webrtc-rtp-congestion-control">
<h1>WebRTC RTP Congestion Control<a class="headerlink" href="#webrtc-rtp-congestion-control" title="Permalink to this headline">¶</a></h1>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Abstract</strong></p></td>
<td><p>WebRTC RTP 拥塞控制</p></td>
</tr>
<tr class="row-even"><td><p><strong>Authors</strong></p></td>
<td><p>Walter Fan</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Status</strong></p></td>
<td><p>WIP</p></td>
</tr>
<tr class="row-even"><td><p><strong>Updated</strong></p></td>
<td><p>2021-10-31</p></td>
</tr>
</tbody>
</table>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id9">简介</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id10">基本架构</a></p></li>
<li><p><a class="reference internal" href="#id3" id="id11">术语</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id12">交互式实时媒体的拥塞控制的需求</a></p></li>
<li><p><a class="reference internal" href="#smooth-paced-sender" id="id13">平滑发送 Smooth/Paced Sender</a></p></li>
<li><p><a class="reference internal" href="#google-congestion-control" id="id14">Google Congestion Control</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id15">测试与验证</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id16">参考代码</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id17">参考资料</a></p>
<ul>
<li><p><a class="reference internal" href="#congestion-control-for-webrtc-standardization-status-and-open-issues" id="id18">Congestion Control for WebRTC: Standardization Status and Open Issues</a></p>
<ul>
<li><p><a class="reference internal" href="#goal" id="id19">Goal</a></p></li>
<li><p><a class="reference internal" href="#design" id="id20">Design</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id9">简介</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>视频会议需要低延迟和高带宽</p>
<ul class="simple">
<li><p>基于延迟的控制器 delay-based controller</p></li>
<li><p>基于丢包的控制器 loss-based controller</p></li>
</ul>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id10">基本架构</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>在发送方，根据 RTCP Receiver Report 中的 faction lost 得知丢包率，可以调整发送的码率</p>
<p>在接收方，根据 RTP 包到达的时间延迟，通过 arrival time filter, 估算出网络延迟 m(ti), 经过 over-user detector 来判断当前网络的拥塞情况， 再由 Remote rate controller 根据规则计算出最大码率 Ar, 通过 RTCP REMB 消息将 Ar 发回给发送方。 发送方再由 A_s, A_r 和配置，计算出目标的码率 A, 应用到 Encoder 和 Packed Sender 来控制发送方的码率。</p>
<img alt="gcc-architecture" src="../_images/gcc-architecture.png" />
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id11">术语</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>RMCAT: RTP Media Congestion Avoidance Techniques 即 RTP 媒体拥塞避免技术</p></li>
<li><p>排队延迟</p></li>
<li><p>延迟梯度</p></li>
<li><p>卡尔曼滤波</p></li>
<li><p>inter-depature delta time</p></li>
<li><p>inter-arrival delta time</p></li>
<li><p>inter-group delay variation</p></li>
<li><p>BBR</p></li>
<li><p>PCC</p></li>
</ul>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id12">交互式实时媒体的拥塞控制的需求</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>基本要求：在最多几百毫秒之内，接收方能够连贯流畅地听到或看到发送方的声音，图像或视频。</p>
<p>具体要求, 参见 <cite>RFC8836</cite></p>
<ol class="arabic simple">
<li><p>The congestion control algorithm MUST attempt to provide as-low-as-possible-delay transit for interactive real-time traffic while still providing a useful amount of bandwidth.</p></li>
<li><p>The algorithm MUST be fair to other flows, both real-time flows (such as other instances of itself) and TCP flows, both long-lived flows and bursts such as the traffic generated by a typical web-browsing session.</p></li>
<li><p>The algorithm SHOULD NOT starve competing TCP flows and SHOULD, as best as possible, avoid starvation by TCP flows</p></li>
<li><p>The algorithm SHOULD adapt as quickly as possible to initial network conditions at the start of a flow.</p></li>
<li><p>The algorithm SHOULD be stable if the RTP streams are halted or discontinuous (for example, when using Voice Activity Detection).</p></li>
<li><p>Where possible, the algorithm SHOULD merge information across multiple RTP streams sent between two endpoints when those RTP streams share a common bottleneck, whether or not those streams are multiplexed onto the same ports.</p></li>
<li><p>The algorithm SHOULD NOT require any special support from network elements to be able to convey congestion-related information.</p></li>
<li><p>Since the assumption here is a set of RTP streams, the backchannel typically SHOULD be done via the RTP Control Protocol (RTCP)</p></li>
<li><p>Flows managed by this algorithm and flows competing against each other at a bottleneck may have different Differentiated Services Code Point (DSCP) [RFC5865] markings depending on the type of traffic or may be subject to flow-based QoS.</p></li>
<li><p>The algorithm SHOULD sense the unexpected lack of backchannel information as a possible indication of a channel-overuse problem and react accordingly to avoid burst events causing a congestion collapse.</p></li>
<li><p>The algorithm SHOULD be stable and maintain low delay when faced  with Active Queue Management (AQM) algorithms.  Also note that these algorithms may apply across multiple queues in the bottleneck or to a single queue.</p></li>
</ol>
</div>
<div class="section" id="smooth-paced-sender">
<h2><a class="toc-backref" href="#id13">平滑发送 Smooth/Paced Sender</a><a class="headerlink" href="#smooth-paced-sender" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>send rate</p></li>
<li><p>ack rate</p></li>
</ul>
</div>
<div class="section" id="google-congestion-control">
<h2><a class="toc-backref" href="#id14">Google Congestion Control</a><a class="headerlink" href="#google-congestion-control" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li><p>到达时间滤波器 arrival time filter</p></li>
</ol>
<p>两个包发送的间隔 T(i) – T(i-1) 和接收的间隔 t(i) – t(i-1) 在理想情况下是相同的，实际上会有不同.
也就是说包的到达时间并未保持稳定的速度。 在计算的时候可以用以帧分组，对两个组的到达时间进行计算。</p>
<img alt="packet transmission delay" src="../_images/rtp_packet_skew.png" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># 发送间隔与到达时间之间的延时
d(i) = t(i) – t(i-1) – (T(i) – T(i-1))

# 两组包之间的大小之差
dL(i) = L(i) - l(i-1)

# C(i) 表示带宽
d(i) = dL(i)/C(i) + m(i) + v(i)

其中dL(i)表示相邻两帧的长度差，
C(i)表示网络信道容量，
m(i)表示网络排队延迟，
v(i)表示网络抖动或其他延迟噪声。

C(i) 是我们想预测的带宽，m(i)即是我们要求得的网络排队延迟, 可由 Kalman Filter 求得
</pre></div>
</div>
<p>T(i)是第i个数据包组中第一个数据包的发送时间，t(i)是第i个数据包组中最后一个数据包的到达时间</p>
<ol class="arabic simple" start="2">
<li><p>过载检查器 over-use detector</p></li>
<li><p>速率控制器 rate controller</p></li>
</ol>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id15">测试与验证</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id16">参考代码</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/">https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/</a>
- congestion_controller/
- remote_bitrate_estimator/</p></li>
</ul>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id17">参考资料</a><a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://tools.ietf.org/html/draft-alvestrand-rmcat-remb-03">REMB</a> : RTCP message for Receiver Estimated Maximum Bitrate</p></li>
<li><p><a class="reference external" href="https://datatracker.ietf.org/doc/html/draft-alvestrand-rmcat-congestion-03">A Google Congestion Control Algorithm for Real-Time Communication</a></p></li>
<li><p><a class="reference external" href="https://c3lab.poliba.it/images/6/65/Gcc-analysis.pdf">Analysis and Design of the Google Congestion Control for WebRTC</a></p></li>
<li><p><a class="reference external" href="https://www.cnblogs.com/wangyiyunxin/p/11122003.html">GCC Introduction</a></p></li>
<li><p><a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc8825">RFC8825</a>: Overview: Real-Time Protocols for Browser-Based Applications</p></li>
<li><p><a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc8836">RFC8836</a>: Congestion Control Requirements for Interactive Real-Time Media</p></li>
<li><p><a class="reference external" href="https://www.rfcreader.com/#rfc8083">RFC8083</a>: Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions</p></li>
<li><p><a class="reference external" href="https://datatracker.ietf.org/wg/rmcat/documents/">RMCAT documents</a>: RTP Media Congestion Avoidance Techniques documents</p></li>
</ul>
<div class="section" id="congestion-control-for-webrtc-standardization-status-and-open-issues">
<h3><a class="toc-backref" href="#id18">Congestion Control for WebRTC: Standardization Status and Open Issues</a><a class="headerlink" href="#congestion-control-for-webrtc-standardization-status-and-open-issues" title="Permalink to this headline">¶</a></h3>
<div class="sidebar">
<p class="sidebar-title">Congestion Control for WebRTC: Standardization Status and Open Issues</p>
<p class="sidebar-subtitle">Author: Luca De Cicco, Gaetano Carlucci, and Saverio Mascolo</p>
<p>The suggested approach is to multiplex all the RTP packet streams in a single RTP session sent over one transport layer flow to reduce the number of flows to be handled by NATs.</p>
<p>Following this approach, the Media Congestion Control algorithm computes the total sending rate A for the aggregated RTP session based on a set of metrics measured at the receiver and sent back
through RTCP packets.</p>
<p>A rate allocation module allocates a fraction Ai of the total bitrate A to each media stream. In particular, each media stream is compressed at a target encoding rate  Ai  such that the sum of all these rates equals the computed sending rate A.</p>
<p>The media streams are then multiplexed over a single RTP session that feeds a sending engine. This module is responsible for sending the RTP packets to the network at a rate as close as possible to the rate computed by the congestion control algorithm.</p>
<p>It is worth noting that the placement of the congestion control algorithm is not specified and
could be sender-side, receiver-side, or distributed both at sender and receiver.</p>
<p>As an example, Fig. 1 shows the case where the congestion control algorithm is placed only at the sender. The receiver is required to implement a module that  measures metrics to be fed back to the congestion control algorithm through RTCP packets.</p>
<p>The section “Open Issues” will discuss the implications that such an architectural choice has on
system scalability and deployability.</p>
</div>
<img alt="WebRTC media application architecture" src="../_images/webrtc-media-architecture.png" />
<table class="colwidths-given docutils align-default" id="id8">
<caption><span class="caption-text">WEBRTC media flow requirements</span><a class="headerlink" href="#id8" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>Requirement</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Latency</p></td>
<td><p>Possibly lower than 100ms</p></td>
</tr>
<tr class="row-odd"><td><p>Packet losses</p></td>
<td><p>Should be minimized, FEC mechanism may be employed</p></td>
</tr>
<tr class="row-even"><td><p>Throughput</p></td>
<td><p>Should be as high as possible</p></td>
</tr>
<tr class="row-odd"><td><p>Burstiness</p></td>
<td><p>A smooth sending-rate should be produced</p></td>
</tr>
<tr class="row-even"><td><p>Fairness</p></td>
<td><p>Should fairly share the bandwidth with real-time and data flows</p></td>
</tr>
<tr class="row-odd"><td><p>Starvation</p></td>
<td><p>Media flows should not be starved when competing with TCP flows</p></td>
</tr>
<tr class="row-even"><td><p>Network support</p></td>
<td><p>No special network support should be required to operate</p></td>
</tr>
</tbody>
</table>
<div class="section" id="goal">
<h4><a class="toc-backref" href="#id19">Goal</a><a class="headerlink" href="#goal" title="Permalink to this headline">¶</a></h4>
<p>the goal of the congestion control algorithm is to produce a sending rate as close as possible to the available end-to-end bandwidth while maintaining the queue occupancy as low as possible.</p>
<p>Additionally, media flows generated by WebRTC applications should fairly share network bandwidth with other concurrent flows.</p>
</div>
<div class="section" id="design">
<h4><a class="toc-backref" href="#id20">Design</a><a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h4>
<p>The design of an algorithm meeting these requirements is faced with several choices
with respect to</p>
<ol class="arabic simple">
<li><p>The transport protocol</p></li>
<li><p>Congestion detection</p></li>
<li><p>The actuation mechanism to be employed</p></li>
</ol>
<p>The approaches to detect congestion through end-to-end measurements can be divided into
two main categories:</p>
<ol class="arabic simple">
<li><p>Loss-based algorithms, detecting congestion based on packet loss events</p></li>
<li><p>Delay-based algorithms, detecting congestion based on latency measurements.</p></li>
</ol>
<p>Congestion detection can be either implicit,when based on end-to-end measurements performed at the end-points, or explicit, when congestion is measured directly in network elements by monitoring the router buffers lengths.</p>
<p>Delay-based algorithms are preferred to loss-based algorithms due to two reasons:</p>
<ul class="simple">
<li><p>first, delay-based schemes can detect congestion before packets are lost due to buffer overflows;</p></li>
<li><p>second, loss based algorithms cannot control queuing delays since they continuously probe for the network available bandwidth by filling and draining Internet buffers, generating significant delay variations.</p></li>
</ul>
<p>Notice that explicitly controlling queuing delays is necessary, since excessively large buffers may
lead to latencies of the order of seconds [2].
An important issue to be taken into account is to prevent delay-based flows from being starved when
competing with loss-based flows in the best-effort Internet [7].
Congestion control algorithms may complement end-to-end measurements with explicit congestion signals sent from network elements to end-points through, for instance, the use of the explicit congestion notification (ECN) mechanism.</p>
<p>Concerning the actuation mechanism, the congestion control algorithm can either compute a congestion window (window-based approach) or explicitly compute a sending rate(rate-based approach).</p>
<p><strong>The use of rate-based mechanisms makes it possible to directly use the rate computed by the congestion control algorithm to drive the media encoders, whereas in the case of window-based algorithms, a proper conversion from a window to a rate should be performed.</strong></p>
<img alt="Two consecutive RTP packets are sent at time Ti–1 and Ti and received at time ti–1 and ti" src="../_images/rtp_packet_skew.png" />
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="insertable_stream.html" class="btn btn-neutral float-right" title="Insertable Stream" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="webrtc_rtx.html" class="btn btn-neutral float-left" title="WebRTC RTX" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, walter.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>