

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Insertable Stream &mdash; webrtc_tutorial 1 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Media Metrics" href="media_metrics.html" />
    <link rel="prev" title="SFU Server" href="sfu.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> webrtc_tutorial
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../outline.html">目录</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1.basic/index.html">1. WebRTC 基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2.transport/index.html">2. WebRTC 传输</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3.media/index.html">3. WebRTC 媒体</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">4. WebRTC 实践</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">WebRTC 实践篇</a></li>
<li class="toctree-l2"><a class="reference internal" href="wasm.html">WebAssebly</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfu.html">SFU Server</a></li>
<li class="toctree-l2"><a class="reference internal" href="sfu.html#reactor">Reactor</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Insertable Stream</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">概述</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">所解决的问题</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#stream-api">Stream API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">用例</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">模型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#readablestream">可读流 ReadableStream</a></li>
<li class="toctree-l4"><a class="reference internal" href="#writablestream">可写流 WritableStream</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pipe-chains">管道链 Pipe chains</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#insertable-streams-api">可插入流 Insertable Streams API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sframetransform">SFrameTransform</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rtcrtpscripttransform">RTCRtpScriptTransform</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id5">案例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#webrtc-insertable-streams">通过 WebRTC Insertable Streams 实现的真正的端到端加密</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="media_metrics.html">Media Metrics</a></li>
<li class="toctree-l2"><a class="reference internal" href="web_codec.html">Web Codecs</a></li>
<li class="toctree-l2"><a class="reference internal" href="web_transport.html">Web Transport</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5.tool/index.html">5. WebRTC 工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6.misc/index.html">6. WebRTC 关联技术</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">webrtc_tutorial</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">4. WebRTC 实践</a> &raquo;</li>
        
      <li>Insertable Stream</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/4.practice/insertable_stream.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="insertable-stream">
<h1>Insertable Stream<a class="headerlink" href="#insertable-stream" title="Permalink to this headline">¶</a></h1>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Abstract</strong></p></td>
<td><p>WebRTC Insertable Stream</p></td>
</tr>
<tr class="row-even"><td><p><strong>Authors</strong></p></td>
<td><p>Walter Fan</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Status</strong></p></td>
<td><p>WIP</p></td>
</tr>
<tr class="row-even"><td><p><strong>Updated</strong></p></td>
<td><p>2021-10-16</p></td>
</tr>
</tbody>
</table>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id6">概述</a></p>
<ul>
<li><p><a class="reference internal" href="#id2" id="id7">所解决的问题</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#stream-api" id="id8">Stream API</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id9">用例</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id10">模型</a></p></li>
<li><p><a class="reference internal" href="#readablestream" id="id11">可读流 ReadableStream</a></p></li>
<li><p><a class="reference internal" href="#writablestream" id="id12">可写流 WritableStream</a></p></li>
<li><p><a class="reference internal" href="#pipe-chains" id="id13">管道链 Pipe chains</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#insertable-streams-api" id="id14">可插入流 Insertable Streams API</a></p>
<ul>
<li><p><a class="reference internal" href="#sframetransform" id="id15">SFrameTransform</a></p></li>
<li><p><a class="reference internal" href="#rtcrtpscripttransform" id="id16">RTCRtpScriptTransform</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#id5" id="id17">案例</a></p>
<ul>
<li><p><a class="reference internal" href="#webrtc-insertable-streams" id="id18">通过 WebRTC Insertable Streams 实现的真正的端到端加密</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reference" id="id19">Reference</a></p></li>
</ul>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id6">概述</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Insertable Stream 可插入的流是新的 WebRTC API, 可用来操作通过 RTCPeerConnection 传送的 MediaStreamTracks 中的每一个字节。它让上层应用能对 WebRTC 底层媒体进行访问，让以往 WebRTC 应用中许多不可能做的情况都成为可能了</p>
<p>比如替换视频聊天时的背景，实时进行音视频处理（降噪，美颜，打水印，加特效等）</p>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id7">所解决的问题</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>我们需要 WebRTC 提供 API</p>
<ul class="simple">
<li><p>允许用户指定的处理，而不仅仅只能通过浏览器</p></li>
<li><p>允许浏览器处理由用户处理过的数据，就好像它是通过正常的处理管道一样</p></li>
<li><p>允许使用 WASM 等技术实现更有效的媒体处理</p></li>
<li><p>允许使用像 Workers 这样的技术来避免主线程阻塞</p></li>
<li><p>不会对当前通信的安全或隐私产生负面影响</p></li>
</ul>
</div>
</div>
<div class="section" id="stream-api">
<h2><a class="toc-backref" href="#id8">Stream API</a><a class="headerlink" href="#stream-api" title="Permalink to this headline">¶</a></h2>
<p>Streams 标准提供了一组通用的 API，用于创建此类流数据并与之交互，这些数据体现在可读流、可写流和转换流中。</p>
<ul class="simple">
<li><p>readable streams</p></li>
<li><p>writable streams</p></li>
<li><p>transform streams</p></li>
</ul>
<p>这些 API 旨在更有效地映射到低级的 I/O 原始操作，包括在适当的情况下对字节流进行专门的处理。</p>
<p>它们允许将多个流轻松组合到管道链中，或者可以通过读取器和写入器直接使用。 最后，它们被设计为自动提供背压和排队。</p>
<ul class="simple">
<li><p>阅读 <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts">Streams API Concepts</a> 来了解背后的基本概念</p></li>
</ul>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id9">用例</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>视频特效: 传入一个视频流 ，通过 transform stream 来实时地应用特效</p></li>
<li><p>解压： 传入一个文件流，通过 transform stream 有选择地从压缩包中解压文件，当用户滚动浏览图库时将它们转换为 img 元素。</p></li>
<li><p>图像解码：传入一个 HTTP 响应流，通过 transform stream 将字节流解码为 bitmap，再接一个 transform stream 将 bitmap 转换为 png</p></li>
</ul>
</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id10">模型</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>一个数据块，称之为 chunk，它是从一个流中读入或写出的一个数据片段，它可以是任意类型，一个流甚至可以包含不同类型的 chunk</p>
<p>对于给定的流，chunk 通常不是最原子的数据单元； 例如，字节流可能包含由 16 KiB Uint8Array 组成的块，而不是单个字节。</p>
</div>
<div class="section" id="readablestream">
<h3><a class="toc-backref" href="#id11">可读流 ReadableStream</a><a class="headerlink" href="#readablestream" title="Permalink to this headline">¶</a></h3>
<p>readable stream 是在 JavaScript 中由来自底层的 ReadableStream 对象表示的数据源——这是网络上或者本地某个地方的资源，可以从中获取数据。</p>
<img alt="../_images/readable_streams.png" src="../_images/readable_streams.png" />
<p>有两种类型的底层数据源：</p>
<ol class="arabic simple">
<li><p>推送源 Push sources，它在您访问它时不断向您推送数据，可以开始、暂停或取消对流的访问，例如视频流和 TCP/Web 套接字中的数据流。</p></li>
<li><p>拉取源 Pull sources： 它要求您在连接后明确向它们请求数据，例如通过过 Fetch 或 XHR 调用进行的文件访问操作.</p></li>
</ol>
<p>ReadableStream 代码示例：</p>
<div class="highlight-JavaScript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">stream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ReadableStream</span><span class="p">({</span>
        <span class="nx">start</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span> <span class="p">{</span>

        <span class="p">},</span>
        <span class="nx">pull</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span> <span class="p">{</span>

        <span class="p">},</span>
        <span class="nx">cancel</span><span class="p">()</span> <span class="p">{</span>

        <span class="p">},</span>
        <span class="nx">type</span><span class="p">,</span>
        <span class="nx">autoAllocateChunkSize</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="nx">highWaterMark</span><span class="p">,</span>
        <span class="nx">size</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="writablestream">
<h3><a class="toc-backref" href="#id12">可写流 WritableStream</a><a class="headerlink" href="#writablestream" title="Permalink to this headline">¶</a></h3>
<p>可写流是您可以写入数据的目的地，在 JavaScript 中由 WritableStream 对象表示。 它用作对于底层接收器之上的抽象，一个可写入原始数据的底层的 I/O sink。</p>
<img alt="../_images/writable_streams.png" src="../_images/writable_streams.png" />
<p>WritableStream 代码示例：</p>
<div class="highlight-JavaScript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">stream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WritableStream</span><span class="p">({</span>
        <span class="nx">start</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span> <span class="p">{</span>

        <span class="p">},</span>
        <span class="nx">write</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span><span class="nx">controller</span><span class="p">)</span> <span class="p">{</span>

        <span class="p">},</span>
        <span class="nx">close</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span> <span class="p">{</span>

        <span class="p">},</span>
        <span class="nx">abort</span><span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>

        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="nx">highWaterMark</span><span class="p">,</span>
        <span class="nx">size</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="pipe-chains">
<h3><a class="toc-backref" href="#id13">管道链 Pipe chains</a><a class="headerlink" href="#pipe-chains" title="Permalink to this headline">¶</a></h3>
<p>Stream API 可以用一个称为 pipe chain 的结构将这些流一个一个串起来，具体方法有 pipeThrough 和 pipeTo</p>
<img alt="../_images/pipechain.png" src="../_images/pipechain.png" />
</div>
</div>
<div class="section" id="insertable-streams-api">
<h2><a class="toc-backref" href="#id14">可插入流 Insertable Streams API</a><a class="headerlink" href="#insertable-streams-api" title="Permalink to this headline">¶</a></h2>
<p>可插入流其实指的是一种转换流，它意为可以在媒体流的处理过程中插入一些处理逻辑。
它可使用 RTCRtpSender 和 RTCRtpReceiver 上附加的 API 来将处理代码插入媒体流的处理管道。</p>
<div class="highlight-WebIDL notranslate"><div class="highlight"><pre><span></span><span class="c1">// New dictionary</span>
<span class="k">dictionary</span> <span class="nc">RTCInsertableStreams</span> <span class="p">{</span>
    <span class="nc">ReadableStream</span> <span class="nv">readable</span><span class="p">;</span>
    <span class="nc">WritableStream</span> <span class="nv">writable</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="p">(</span><span class="nc">SFrameTransform</span> <span class="k">or</span> <span class="nc">RTCRtpScriptTransform</span><span class="p">)</span> <span class="nc">RTCRtpTransform</span><span class="p">;</span>

<span class="c1">// New methods for RTCRtpSender and RTCRtpReceiver</span>
<span class="k">partial</span> <span class="k">interface</span> <span class="nc">RTCRtpSender</span> <span class="p">{</span>
    <span class="k">attribute</span> <span class="nc">RTCRtpTransform</span><span class="p">?</span> <span class="nv">transform</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">partial</span> <span class="k">interface</span> <span class="nc">RTCRtpReceiver</span> <span class="p">{</span>
    <span class="k">attribute</span> <span class="nc">RTCRtpTransform</span><span class="p">?</span> <span class="nv">transform</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>由上面的定义可知，可插入流通过转换器 RTCRtpTransform 来实现，有两种转换器</p>
<ol class="arabic simple">
<li><p>SFrameTransform: 主要用来加解密， S 是 Secure 的首字母</p></li>
<li><p>RTCRtpScriptTransform：指对一般的 audio/video 帧的转换</p></li>
</ol>
<div class="section" id="sframetransform">
<h3><a class="toc-backref" href="#id15">SFrameTransform</a><a class="headerlink" href="#sframetransform" title="Permalink to this headline">¶</a></h3>
<p>接口定义如下</p>
<div class="highlight-JavaScript notranslate"><div class="highlight"><pre><span></span><span class="kr">enum</span> <span class="nx">SFrameTransformRole</span> <span class="p">{</span>
    <span class="s2">&quot;encrypt&quot;</span><span class="p">,</span>
    <span class="s2">&quot;decrypt&quot;</span>
<span class="p">};</span>

<span class="nx">dictionary</span> <span class="nx">SFrameTransformOptions</span> <span class="p">{</span>
    <span class="nx">SFrameTransformRole</span> <span class="nx">role</span> <span class="o">=</span> <span class="s2">&quot;encrypt&quot;</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">typedef</span> <span class="p">[</span><span class="nx">EnforceRange</span><span class="p">]</span> <span class="nx">unsigned</span> <span class="kr">long</span> <span class="kr">long</span> <span class="nx">SmallCryptoKeyID</span><span class="p">;</span>
<span class="nx">typedef</span> <span class="p">(</span><span class="nx">SmallCryptoKeyID</span> <span class="nx">or</span> <span class="nx">bigint</span><span class="p">)</span> <span class="nx">CryptoKeyID</span><span class="p">;</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span> <span class="nx">SFrameTransform</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="nx">optional</span> <span class="nx">SFrameTransformOptions</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{});</span>
    <span class="nb">Promise</span><span class="o">&lt;</span><span class="kc">undefined</span><span class="o">&gt;</span> <span class="nx">setEncryptionKey</span><span class="p">(</span><span class="nx">CryptoKey</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">optional</span> <span class="nx">CryptoKeyID</span> <span class="nx">keyID</span><span class="p">);</span>
    <span class="nx">attribute</span> <span class="nx">EventHandler</span> <span class="nx">onerror</span><span class="p">;</span>
<span class="p">};</span>
<span class="nx">SFrameTransform</span> <span class="nx">includes</span> <span class="nx">GenericTransformStream</span><span class="p">;</span>

<span class="kr">enum</span> <span class="nx">SFrameTransformErrorEventType</span> <span class="p">{</span>
    <span class="s2">&quot;authentication&quot;</span><span class="p">,</span>
    <span class="s2">&quot;keyID&quot;</span><span class="p">,</span>
    <span class="s2">&quot;syntax&quot;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span> <span class="nx">SFrameTransformErrorEvent</span> <span class="o">:</span> <span class="nx">Event</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="nx">DOMString</span> <span class="nx">type</span><span class="p">,</span> <span class="nx">SFrameTransformErrorEventInit</span> <span class="nx">eventInitDict</span><span class="p">);</span>

    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">SFrameTransformErrorEventType</span> <span class="nx">errorType</span><span class="p">;</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">CryptoKeyID</span><span class="o">?</span> <span class="nx">keyID</span><span class="p">;</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">any</span> <span class="nx">frame</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">dictionary</span> <span class="nx">SFrameTransformErrorEventInit</span> <span class="o">:</span> <span class="nx">EventInit</span> <span class="p">{</span>
    <span class="nx">required</span> <span class="nx">SFrameTransformErrorEventType</span> <span class="nx">errorType</span><span class="p">;</span>
    <span class="nx">required</span> <span class="nx">any</span> <span class="nx">frame</span><span class="p">;</span>
    <span class="nx">CryptoKeyID</span><span class="o">?</span> <span class="nx">keyID</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="rtcrtpscripttransform">
<h3><a class="toc-backref" href="#id16">RTCRtpScriptTransform</a><a class="headerlink" href="#rtcrtpscripttransform" title="Permalink to this headline">¶</a></h3>
<p>接口定义如下</p>
<div class="highlight-JavaScript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 定义视频帧的类型，最终会由 WebCodecs 标准来定义</span>
<span class="kr">enum</span> <span class="nx">RTCEncodedVideoFrameType</span> <span class="p">{</span>
    <span class="s2">&quot;empty&quot;</span><span class="p">,</span>
    <span class="s2">&quot;key&quot;</span><span class="p">,</span>
    <span class="s2">&quot;delta&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">dictionary</span> <span class="nx">RTCEncodedVideoFrameMetadata</span> <span class="p">{</span>
    <span class="kr">long</span> <span class="kr">long</span> <span class="nx">frameId</span><span class="p">;</span>
    <span class="nx">sequence</span><span class="o">&lt;</span><span class="kr">long</span> <span class="kr">long</span><span class="o">&gt;</span> <span class="nx">dependencies</span><span class="p">;</span>
    <span class="nx">unsigned</span> <span class="kr">short</span> <span class="nx">width</span><span class="p">;</span>
    <span class="nx">unsigned</span> <span class="kr">short</span> <span class="nx">height</span><span class="p">;</span>
    <span class="kr">long</span> <span class="nx">spatialIndex</span><span class="p">;</span>
    <span class="kr">long</span> <span class="nx">temporalIndex</span><span class="p">;</span>
    <span class="kr">long</span> <span class="nx">synchronizationSource</span><span class="p">;</span>
    <span class="nx">sequence</span><span class="o">&lt;</span><span class="kr">long</span><span class="o">&gt;</span> <span class="nx">contributingSources</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">//定义编码过的 video 和 audio 帧. 最终会由 WebCodecs 标准来定义.</span>
<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span> <span class="nx">RTCEncodedVideoFrame</span> <span class="p">{</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">RTCEncodedVideoFrameType</span> <span class="nx">type</span><span class="p">;</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">unsigned</span> <span class="kr">long</span> <span class="kr">long</span> <span class="nx">timestamp</span><span class="p">;</span>
    <span class="nx">attribute</span> <span class="nx">ArrayBuffer</span> <span class="nx">data</span><span class="p">;</span>
    <span class="nx">RTCEncodedVideoFrameMetadata</span> <span class="nx">getMetadata</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">//音频帧的元数据，包含RTP中定义的 SSRC, CSRC</span>
<span class="nx">dictionary</span> <span class="nx">RTCEncodedAudioFrameMetadata</span> <span class="p">{</span>
    <span class="kr">long</span> <span class="nx">synchronizationSource</span><span class="p">;</span>
    <span class="nx">sequence</span><span class="o">&lt;</span><span class="kr">long</span><span class="o">&gt;</span> <span class="nx">contributingSources</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="p">(</span><span class="nx">Window</span><span class="p">,</span><span class="nx">DedicatedWorker</span><span class="p">)]</span>
<span class="kr">interface</span> <span class="nx">RTCEncodedAudioFrame</span> <span class="p">{</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">unsigned</span> <span class="kr">long</span> <span class="kr">long</span> <span class="nx">timestamp</span><span class="p">;</span>
    <span class="nx">attribute</span> <span class="nx">ArrayBuffer</span> <span class="nx">data</span><span class="p">;</span>
    <span class="nx">RTCEncodedAudioFrameMetadata</span> <span class="nx">getMetadata</span><span class="p">();</span>
<span class="p">};</span>


<span class="c1">// 定义 JavaScript-based transforms.</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="nx">DedicatedWorker</span><span class="p">]</span>
<span class="kr">interface</span> <span class="nx">RTCTransformEvent</span> <span class="o">:</span> <span class="nx">Event</span> <span class="p">{</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">RTCRtpScriptTransformer</span> <span class="nx">transformer</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">partial</span> <span class="kr">interface</span> <span class="nx">DedicatedWorkerGlobalScope</span> <span class="p">{</span>
    <span class="nx">attribute</span> <span class="nx">EventHandler</span> <span class="nx">onrtctransform</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="nx">DedicatedWorker</span><span class="p">]</span>
<span class="kr">interface</span> <span class="nx">RTCRtpScriptTransformer</span> <span class="p">{</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">ReadableStream</span> <span class="nx">readable</span><span class="p">;</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">WritableStream</span> <span class="nx">writable</span><span class="p">;</span>
    <span class="nx">readonly</span> <span class="nx">attribute</span> <span class="nx">any</span> <span class="nx">options</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">[</span><span class="nx">Exposed</span><span class="o">=</span><span class="nx">Window</span><span class="p">]</span>
<span class="kr">interface</span> <span class="nx">RTCRtpScriptTransform</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="nx">Worker</span> <span class="nx">worker</span><span class="p">,</span> <span class="nx">optional</span> <span class="nx">any</span> <span class="nx">options</span><span class="p">,</span> <span class="nx">optional</span> <span class="nx">sequence</span><span class="o">&lt;</span><span class="nx">object</span><span class="o">&gt;</span> <span class="nx">transfer</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id17">案例</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="webrtc-insertable-streams">
<h3><a class="toc-backref" href="#id18">通过 WebRTC Insertable Streams 实现的真正的端到端加密</a><a class="headerlink" href="#webrtc-insertable-streams" title="Permalink to this headline">¶</a></h3>
<p>搭建一个本地的 peer connection, video1 元素放置本地获取的 stream, video2 元素放置从远程获取的 stream</p>
<p>这里也放置了一个 videoMonitor 元素来模拟为中间人 middlebox, 它从 peer connection 中拿到媒体流，不经 decode 而直接播放。</p>
<p>大致流程为:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">localStream</span><span class="p">(</span><span class="n">video1</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="n">加密</span> <span class="o">--&gt;</span> <span class="n">peerConnection</span> <span class="o">--&gt;</span> <span class="n">解密</span> <span class="o">--&gt;</span> <span class="n">video2</span><span class="p">(</span><span class="n">remoteStream</span><span class="p">)</span>
                                    <span class="o">|</span>
                                    <span class="n">v</span>
                                <span class="n">videoMonitor</span><span class="p">(</span><span class="n">未解密的</span><span class="p">)</span>
</pre></div>
</div>
<p>从 RTCPeerConnection 中获取 RTCRtpSender 和 RTCRtpReceiver</p>
<ul class="simple">
<li><p>explain: <a class="reference external" href="https://webrtchacks.com/true-end-to-end-encryption-with-webrtc-insertable-streams/">https://webrtchacks.com/true-end-to-end-encryption-with-webrtc-insertable-streams/</a></p></li>
<li><p>codes: <a class="reference external" href="https://github.com/webrtc/samples/tree/gh-pages/src/content/insertable-streams/endtoend-encryption">https://github.com/webrtc/samples/tree/gh-pages/src/content/insertable-streams/endtoend-encryption</a></p></li>
</ul>
<img alt="../_images/insertable_stream_example.png" src="../_images/insertable_stream_example.png" />
<p>下面的代码演示如何在原本发送到远端的视频流，RTCRtpSender 中的数据流是</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">readableStream</span> <span class="o">--&gt;</span> <span class="n">writableStream</span>
</pre></div>
</div>
<p>现在在中间插入一个转换流</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">readableStream</span> <span class="o">--&gt;</span> <span class="n">senderTransformStream</span> <span class="o">-&gt;</span> <span class="n">writableStream</span>
</pre></div>
</div>
<p>代码示例：</p>
<div class="highlight-JavaScript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">sender</span> <span class="o">=</span> <span class="nx">pc1</span><span class="p">.</span><span class="nx">addTrack</span><span class="p">(</span><span class="nx">stream</span><span class="p">.</span><span class="nx">getVideoTracks</span><span class="p">()[</span><span class="mf">0</span><span class="p">],</span> <span class="nx">stream</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">senderStreams</span> <span class="o">=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">createEncodedVideoStreams</span><span class="p">()</span> <span class="o">:</span>
<span class="kd">const</span> <span class="nx">senderTransformStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TransformStream</span><span class="p">({</span>
    <span class="nx">transform</span><span class="o">:</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">controller</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//这里可以做加密</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">chunk</span><span class="p">,</span> <span class="nx">chunk</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">);</span>
        <span class="nx">controller</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="nx">senderStreams</span><span class="p">.</span><span class="nx">readableStream</span>
    <span class="p">.</span><span class="nx">pipeThrough</span><span class="p">(</span><span class="nx">senderTransformStream</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">pipeTo</span><span class="p">(</span><span class="nx">senderStreams</span><span class="p">.</span><span class="nx">writableStream</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>完整代码参见 WebRTC example: <a class="reference external" href="https://webrtc.github.io/samples/src/content/insertable-streams/endtoend-encryption/">https://webrtc.github.io/samples/src/content/insertable-streams/endtoend-encryption/</a></p></li>
</ul>
<p>转换流的实现是在一个 web worker 中实现的，主线程与 worker 线程通过消息来通信</p>
<div class="highlight-JavaScript notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s1">&#39;./js/worker.js&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;E2EE worker&#39;</span><span class="p">});</span>
<span class="kd">function</span> <span class="nx">setupSenderTransform</span><span class="p">(</span><span class="nx">sender</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">senderStreams</span> <span class="o">=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">createEncodedStreams</span><span class="p">();</span>

    <span class="kd">const</span> <span class="p">{</span><span class="nx">readable</span><span class="p">,</span> <span class="nx">writable</span><span class="p">}</span> <span class="o">=</span> <span class="nx">senderStreams</span><span class="p">;</span>
    <span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
            <span class="nx">operation</span><span class="o">:</span> <span class="s1">&#39;encode&#39;</span><span class="p">,</span>
            <span class="nx">readable</span><span class="p">,</span>
            <span class="nx">writable</span><span class="p">,</span>
        <span class="p">},</span> <span class="p">[</span><span class="nx">readable</span><span class="p">,</span> <span class="nx">writable</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">setupReceiverTransform</span><span class="p">(</span><span class="nx">receiver</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">receiverStreams</span> <span class="o">=</span> <span class="nx">receiver</span><span class="p">.</span><span class="nx">createEncodedStreams</span><span class="p">();</span>
        <span class="kd">const</span> <span class="p">{</span><span class="nx">readable</span><span class="p">,</span> <span class="nx">writable</span><span class="p">}</span> <span class="o">=</span> <span class="nx">receiverStreams</span><span class="p">;</span>
        <span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span>
            <span class="nx">operation</span><span class="o">:</span> <span class="s1">&#39;decode&#39;</span><span class="p">,</span>
            <span class="nx">readable</span><span class="p">,</span>
            <span class="nx">writable</span><span class="p">,</span>
        <span class="p">},</span> <span class="p">[</span><span class="nx">readable</span><span class="p">,</span> <span class="nx">writable</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>详细代码参见 <a class="reference external" href="https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js">https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js</a></p>
<p>在 worker 中</p>
<ul class="simple">
<li><p>对于 encode 消息的处理就是插入一个用来加密的 transformStream（处理函数为 encodeFunction）</p></li>
<li><p>对于 decode 消息的处理就是插入一个用来解密的 transformStream（处理函数为 decodeFunction）</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">onmessage</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="n">const</span> <span class="p">{</span><span class="n">operation</span><span class="p">}</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">operation</span> <span class="o">===</span> <span class="s1">&#39;encode&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="p">{</span><span class="n">readable</span><span class="p">,</span> <span class="n">writable</span><span class="p">}</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
    <span class="n">const</span> <span class="n">transformStream</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TransformStream</span><span class="p">({</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">encodeFunction</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="o">//</span><span class="n">处理管道经由</span> <span class="n">transformStream</span> <span class="n">的</span> <span class="n">encodeFunction</span> <span class="n">做</span> <span class="n">encode</span>
    <span class="n">readable</span>
        <span class="o">.</span><span class="n">pipeThrough</span><span class="p">(</span><span class="n">transformStream</span><span class="p">)</span>
        <span class="o">.</span><span class="n">pipeTo</span><span class="p">(</span><span class="n">writable</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">operation</span> <span class="o">===</span> <span class="s1">&#39;decode&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">const</span> <span class="p">{</span><span class="n">readable</span><span class="p">,</span> <span class="n">writable</span><span class="p">}</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">data</span><span class="p">;</span>
    <span class="n">const</span> <span class="n">transformStream</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TransformStream</span><span class="p">({</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">decodeFunction</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="o">//</span><span class="n">处理管道经由</span> <span class="n">transformStream</span> <span class="n">的</span> <span class="n">decodeFunction</span> <span class="n">做</span> <span class="n">decode</span>
    <span class="n">readable</span>
        <span class="o">.</span><span class="n">pipeThrough</span><span class="p">(</span><span class="n">transformStream</span><span class="p">)</span>
        <span class="o">.</span><span class="n">pipeTo</span><span class="p">(</span><span class="n">writable</span><span class="p">);</span>

<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">operation</span> <span class="o">===</span> <span class="s1">&#39;setCryptoKey&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">currentCryptoKey</span> <span class="o">!==</span> <span class="n">currentCryptoKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">currentKeyIdentifier</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">currentCryptoKey</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">currentCryptoKey</span><span class="p">;</span>
    <span class="n">useCryptoOffset</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">useCryptoOffset</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li><p>encodeFunction 的实现如下，主要是把视频帧中的数据取出，将视频数据与加密 key 进行异或, 做一个简单的加密，然后再加入 key 的标识和校验和 (checksum), 再把处理过的数据写回 encodedFrame.data。最后，将 encodedFrame 追加到 controller 的队列末尾。</p></li>
</ul>
<div class="highlight-JavaScript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">encodeFunction</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">,</span> <span class="nx">controller</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">scount</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mf">30</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// dump the first 30 packets.</span>
        <span class="nx">dump</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">,</span> <span class="s1">&#39;send&#39;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">currentCryptoKey</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
        <span class="c1">// Any length that is needed can be used for the new buffer.</span>
        <span class="kd">const</span> <span class="nx">newData</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span> <span class="o">+</span> <span class="mf">5</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">newView</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="nx">newData</span><span class="p">);</span>

        <span class="kd">const</span> <span class="nx">cryptoOffset</span> <span class="o">=</span> <span class="nx">useCryptoOffset</span><span class="o">?</span> <span class="nx">frameTypeToCryptoOffset</span><span class="p">[</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">type</span><span class="p">]</span> <span class="o">:</span> <span class="mf">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">cryptoOffset</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">newView</span><span class="p">.</span><span class="nx">setInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">view</span><span class="p">.</span><span class="nx">getInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="c1">// This is a bitwise xor of the key with the payload. This is not strong encryption, just a demo.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">cryptoOffset</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">keyByte</span> <span class="o">=</span> <span class="nx">currentCryptoKey</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="nx">currentCryptoKey</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
            <span class="nx">newView</span><span class="p">.</span><span class="nx">setInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">view</span><span class="p">.</span><span class="nx">getInt8</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="o">^</span> <span class="nx">keyByte</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// Append keyIdentifier.</span>
        <span class="nx">newView</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span><span class="p">,</span> <span class="nx">currentKeyIdentifier</span> <span class="o">%</span> <span class="mh">0xff</span><span class="p">);</span>
        <span class="c1">// Append checksum</span>
        <span class="nx">newView</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">byteLength</span> <span class="o">+</span> <span class="mf">1</span><span class="p">,</span> <span class="mh">0xDEADBEEF</span><span class="p">);</span>

        <span class="nx">encodedFrame</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">newData</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">controller</span><span class="p">.</span><span class="nx">enqueue</span><span class="p">(</span><span class="nx">encodedFrame</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>decodeFunction</p></li>
</ul>
<p>decodeFunction 的实现如下，主要是把视频帧中的数据取出，先检查校验和(checksum), 再检查加密 key 的标识，如果都没问题就用加密 key 与视频数据进行再次异或来实现简单的解密，最后，将 decodedFrame 追加到 controller 的队列末尾。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>function decodeFunction(encodedFrame, controller) {
    if (rcount++ &lt; 30) { // dump the first 30 packets
        dump(encodedFrame, &#39;recv&#39;);
    }
    const view = new DataView(encodedFrame.data);
    const checksum = encodedFrame.data.byteLength &gt; 4 ? view.getUint32(encodedFrame.data.byteLength - 4) : false;
    if (currentCryptoKey) {
        if (checksum !== 0xDEADBEEF) {
            console.log(&#39;Corrupted frame received, checksum &#39; + checksum.toString(16));
            return; // 这可能是加密 key 设定了，但是收到了未加密的视频帧
        }
        const keyIdentifier = view.getUint8(encodedFrame.data.byteLength - 5);
        if (keyIdentifier !== currentKeyIdentifier) {
            // 这是加密 key 和解密的 key 不一致
            console.log(`Key identifier mismatch, got ${keyIdentifier} expected ${currentKeyIdentifier}.`);
            return;
        }

        const newData = new ArrayBuffer(encodedFrame.data.byteLength - 5);
        const newView = new DataView(newData);
        const cryptoOffset = useCryptoOffset? frameTypeToCryptoOffset[encodedFrame.type] : 0;

        for (let i = 0; i &lt; cryptoOffset; ++i) {
            newView.setInt8(i, view.getInt8(i));
        }
        for (let i = cryptoOffset; i &lt; encodedFrame.data.byteLength - 5; ++i) {
            const keyByte = currentCryptoKey.charCodeAt(i % currentCryptoKey.length);
            newView.setInt8(i, view.getInt8(i) ^ keyByte);
        }
        encodedFrame.data = newData;
    } else if (checksum === 0xDEADBEEF) {
        return; // encrypted in-flight frame but we already forgot about the key.
    }
    controller.enqueue(encodedFrame);
}
</pre></div>
</div>
<p>至此，无论是采用 P2P 还是 SFU, 都不怕再有“中间人攻击”，只有通信的双方共享一个加密 key , 他们之间才能看到彼此正常的视频。在实际应用了，加密 key 的管理会更复杂，还需要加盐，加密算法多半会用  AES。</p>
</div>
</div>
<div class="section" id="reference">
<h2><a class="toc-backref" href="#id19">Reference</a><a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://w3c.github.io/webrtc-encoded-transform/">webrtc-encoded-transform</a></p></li>
<li><p><a class="reference external" href="https://github.com/w3c/webrtc-encoded-transform/blob/main/explainer.md">Insertable Stream Explain</a></p></li>
<li><p><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts">Streams API Concepts</a></p></li>
<li><p><a class="reference external" href="https://streams.spec.whatwg.org/">Streams API Spec</a></p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="media_metrics.html" class="btn btn-neutral float-right" title="Media Metrics" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="sfu.html" class="btn btn-neutral float-left" title="SFU Server" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, walter.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>